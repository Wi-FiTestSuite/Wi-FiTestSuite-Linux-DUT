/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *
 *
 *  LICENSE
 *
 *  License is granted only to Wi-Fi Alliance members and designated
 *  contractors (“Authorized Licensees”).N  Authorized Licensees are granted
 *  the non-exclusive, worldwide, limited right to use, copy, import, export
 *  and distribute this software:
 *  (i) solely for noncommercial applications and solely for testing Wi-Fi
 *  equipment; and
 *  (ii) solely for the purpose of embedding the software into Authorized
 *  Licensee’s proprietary equipment and software products for distribution to
 *  its customers under a license with at least the same restrictions as
 *  contained in this License, including, without limitation, the disclaimer of
 *  warranty and limitation of liability, below.N  The distribution rights
 *  granted in clause
 *  (ii), above, include distribution to third party companies who will
 *  redistribute the Authorized Licensee’s product to their customers with or
 *  without such third party’s private label. Other than expressly granted
 *  herein, this License is not transferable or sublicensable, and it does not
 *  extend to and may not be used with non-Wi-Fi applications.N  Wi-Fi Alliance
 *  reserves all rights not expressly granted herein.N 
 *N 
 *  Except as specifically set forth above, commercial derivative works of
 *  this software or applications that use the Wi-Fi scripts generated by this
 *  software are NOT AUTHORIZED without specific prior written permission from
 *  Wi-Fi Alliance.
 *N 
 *  Non-Commercial derivative works of this software for internal use are
 *  authorized and are limited by the same restrictions; provided, however,
 *  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
 *  such derivative works under a perpetual, payment-free license to use,
 *  modify, and distribute such derivative works for purposes of testing Wi-Fi
 *  equipment.
 *N 
 *  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 *  or promote products that are derived from or that use this software without
 *  specific prior written permission from Wi-Fi Alliance.
 *
 *  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR AN PARTICULAR PURPOSE,
 *  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ******************************************************************************
 */


/*
 * File: wfa_ca.c
 *       This is the main program for Control Agent.
 *
 * Revision History:
 *   2006/06/01 -- BETA Release by qhu
 *   2006/06/13 -- 00.02 Release by qhu
 *   2006/06/30 -- 00.10 Release by qhu
 *   2006/07/10 -- 01.00 Release by qhu
 *   2006/09/01 -- 01.05 Release by qhu
 *   2007/01/11 -- 01.10 released by qhu
 *   2007/02/15 -- WMM beta released by qhu, mkaroshi
 *   2007/03/21 -- 01.40 WPA2 and Official WMM Beta release by qhu
 *   2007/04/20 -- 02.00 WPA2 and Official WMM release by qhu
 *   2007/08/15 --  02.10 WMM-Power Save release by qhu
 *   2007/10/10 --  02.20 Voice SOHO beta -- qhu
 *   2007/11/07 -- 02.30 Voice HSO -- qhu
 *      -- on the calls wfaCtrlSend(), the string len is replaced with strlen()
 *   2007/12/10 -- 02.32 update -- qhu
 *   2008/02/11 -- fix the BUG #5, instead of using done/break (suggested), 
 *                 continue is used here. 
 */
#include <stdio.h>      /* for printf() and fprintf() */
#include <sys/socket.h> /* for socket(), connect(), send(), and recv() */
#include <arpa/inet.h>  /* for sockaddr_in and inet_addr() */
#include <stdlib.h>     /* for atoi() and exit() */
#include <string.h>     /* for memset() */
#include <unistd.h>     /* for close() */
#include <sys/select.h>

#include "wfa_debug.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_tlv.h"
#include "wfa_tg.h"
#include "wfa_cmds.h"
#include "wfa_miscs.h"
#include "wfa_sock.h"
#include "wfa_ca.h"
#include "wfa_agtctrl.h"

#define WFA_ENV_AGENT_IPADDR "WFA_ENV_AGENT_IPADDR"

extern int xcCmdProcGetVersion(unsigned char *parms);
extern dutCommandRespFuncPtr wfaCmdRespProcFuncTbl[];
extern typeNameStr_t nameStr[];
extern char gRespStr[];

int gSock = -1, tmsockfd, gCaSockfd = -1, xcSockfd, btSockfd;
int gtgSend, gtgRecv, gtgTransac;
char gnetIf[32] = "any";
tgStream_t    *theStreams;
long          itimeout = 0;

unsigned short wfa_defined_debug = WFA_DEBUG_ERR | WFA_DEBUG_WARNING | WFA_DEBUG_INFO;
unsigned short dfd_lvl = WFA_DEBUG_DEFAULT | WFA_DEBUG_ERR | WFA_DEBUG_INFO;

/*
 * the output format can be redefined for file output.
 */

int main(int argc, char *argv[])
{
    int nfds;
    struct sockaddr_in servAddr;
    unsigned short servPort, myport; 
    char *servIP=NULL, *tstr=NULL;
    int bytesRcvd;                   
    fd_set sockSet;
    char cmdName[WFA_BUFF_32];
    int i, isFound = 0, nbytes, ret_status, slen;
    WORD tag;
    int tmsockfd, cmdLen = WFA_BUFF_1K;
    int maxfdn1;
    BYTE xcCmdBuf[WFA_BUFF_4K];
    BYTE caCmdBuf[WFA_BUFF_4K];
    BYTE pcmdBuf[WFA_BUFF_1K];
    char *pcmdStr = NULL;
    char respStr[WFA_BUFF_512];

	//start of CLI handling variables
	char wfaCliBuff[128];
	FILE *wfaCliFd;
	char * cliCmd,*tempCmdBuff;
    if(argc < 3)
    {
        DPRINT_ERR(WFA_ERR, "Usage: %s <control interface> <local control agent port>\n", argv[0]);
        exit(1);
    }

    myport = atoi(argv[2]); 

    //strcpy(gnetIf, argv[1]);
    if(argc > 3)
    {
        if(argc < 5)
            {
            DPRINT_ERR(WFA_ERR, "Usage: %s <control interface> <local control agent port> <DUT IP ADDRESS> <DUT PORT>\n", argv[0]);
                exit(1);
            }
        servIP = argv[3];
        if(isIpV4Addr(argv[3])== WFA_FAILURE)
            return WFA_FAILURE;
        if(isNumber(argv[4])== WFA_FAILURE)
           return WFA_FAILURE;
        servPort = atoi(argv[4]);
        if(argc > 5)
        {
                FILE *logfile;
                int fd;
                logfile = fopen(argv[5],"a");
                if(logfile != NULL)
                {
                        fd = fileno(logfile);
                        DPRINT_INFO(WFA_OUT,"redirecting the output to %s\n",argv[5]);
                        dup2(fd,1);
                        dup2(fd,2);
                }
                else
                {
                        DPRINT_ERR(WFA_ERR, "Cant open the log file continuing without redirecting\n");
                }
        }
    }
    else
    {
        if((tstr = getenv("WFA_ENV_AGENT_IPADDR")) == NULL)
        {
            DPRINT_ERR(WFA_ERR, "Environment variable WFA_ENV_AGENT_IPADDR not set or specify DUT IP/PORT\n");
                exit(1);
        }
        if(isIpV4Addr(tstr)== WFA_FAILURE)
            return WFA_FAILURE;
        servIP= tstr;
        if((tstr = getenv("WFA_ENV_AGENT_PORT")) == NULL)
        {
           DPRINT_ERR(WFA_ERR, "Environment variable WFA_ENV_AGENT_PORT not set or specify DUT IP/PORT\n");
           exit(1);
        }
        if(isNumber(tstr)== WFA_FAILURE)
           return WFA_FAILURE;
        servPort = atoi(tstr);
    }

    tmsockfd = wfaCreateTCPServSock(myport);

    maxfdn1 = tmsockfd + 1;

    FD_ZERO(&sockSet);
    if(gSock == -1)
    {
        if ((gSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
        {
            DPRINT_ERR(WFA_ERR, "socket() failed: %i", errno);
            exit(1);
        }

        memset(&servAddr, 0, sizeof(servAddr)); 
        servAddr.sin_family      = AF_INET;
        servAddr.sin_addr.s_addr = inet_addr(servIP);
        servAddr.sin_port        = htons(servPort);

        if (connect(gSock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
        {
            DPRINT_ERR(WFA_ERR, "connect() failed: %i", errno);
            exit(1);
        }

    }

    for(;;)
    {
        FD_ZERO(&sockSet);
        FD_SET(tmsockfd, &sockSet);
        maxfdn1 = tmsockfd + 1;

        if(gCaSockfd != -1)
        {
            FD_SET(gCaSockfd, &sockSet);
            if(maxfdn1 < gCaSockfd)
                maxfdn1 = gCaSockfd +1; 
        }

        if(gSock != -1)
        {
            FD_SET(gSock, &sockSet);
            if(maxfdn1 < gSock)
                maxfdn1 = gSock +1; 
        }

        if((nfds = select(maxfdn1, &sockSet, NULL, NULL, NULL)) < 0)
        {
            if(errno == EINTR)
                continue;
            else
                DPRINT_WARNING(WFA_WNG, "select error %i", errno);
        }
 
        DPRINT_INFO(WFA_OUT, "new event \n");
        if(FD_ISSET(tmsockfd, &sockSet))
        {
            gCaSockfd = wfaAcceptTCPConn(tmsockfd);
            DPRINT_INFO(WFA_OUT, "accept new connection\n");
            continue;
        }
   
        if(gCaSockfd > 0 && FD_ISSET(gCaSockfd, &sockSet))
        {
            memset(xcCmdBuf, 0, WFA_BUFF_4K);
            memset(gRespStr, 0, WFA_BUFF_512);

            nbytes = wfaCtrlRecv(gCaSockfd, xcCmdBuf); 
            if(nbytes <=0)
            {
                shutdown(gCaSockfd, SHUT_WR);
                close(gCaSockfd);
                gCaSockfd = -1;
                continue;
            }
    
            /*
             * send back to command line or TM.
             */
            //sleep(1); /* having this is for slowing down unexpected output result on CLI command sometimes */
            memset(respStr, 0, WFA_BUFF_128);
            sprintf(respStr, "status,RUNNING\r\n");
            wfaCtrlSend(gCaSockfd, (BYTE *)respStr, strlen(respStr));

            DPRINT_INFO(WFA_OUT, "%s\n", respStr);
            DPRINT_INFO(WFA_OUT, "message %s %i\n", xcCmdBuf, nbytes);
            slen = (int )strlen((char *)xcCmdBuf);

            DPRINT_INFO(WFA_OUT, "last %x last-1  %x last-2 %x last-3 %x\n", cmdName[slen], cmdName[slen-1], cmdName[slen-2], cmdName[slen-3]);

            xcCmdBuf[slen-3] = '\0';

            if(gSock == -1)
            {
                if ((gSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
                {
                    DPRINT_ERR(WFA_ERR, "socket() failed: %i", errno);
                    exit(1);
                }

                memset(&servAddr, 0, sizeof(servAddr)); 
                servAddr.sin_family      = AF_INET;
                servAddr.sin_addr.s_addr = inet_addr(servIP);
                servAddr.sin_port        = htons(servPort);

                if (connect(gSock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
                {
                    DPRINT_ERR(WFA_ERR, "connect() failed: %i", errno);
                    exit(1);
                }
            }

            isFound = 0;
    
			tempCmdBuff=(char* )malloc(sizeof(xcCmdBuf));
			memcpy(tempCmdBuff,xcCmdBuf,sizeof(xcCmdBuf));
		
			memcpy(cmdName, strtok_r((char *)tempCmdBuff, ",", (char **)&pcmdStr), 32);
			printf("\nInside the CLI huck block \n");

			wfaCliFd=fopen("/etc/WfaEndpoint/wfa_cli.txt","r");
			printf("\nAfter File open \n");
			if(wfaCliFd!= NULL)
			{
				//printf("\nInside File open \n");
				while(fgets(wfaCliBuff, 128, wfaCliFd) != NULL)
				{
					//printf("Line read from CLI file : %s",wfaCliBuff);
					if(ferror(wfaCliFd))
						break;
					cliCmd=strtok(wfaCliBuff,"-");
					if(strcmp(cliCmd,cmdName) == 0)
					{
						strcpy(cmdName,"wfa_cli_cmd");
						pcmdStr = (char *)&xcCmdBuf[0];
						break;
					}
				}
				fclose(wfaCliFd);

			}
			printf("\nOutside the new block \n");
			free(tempCmdBuff);
			if(strcmp(cmdName,"wfa_cli_cmd") != 0)
	            memcpy(cmdName, strtok_r((char *)xcCmdBuf, ",", (char **)&pcmdStr), 32);

			
			i = 0;
            while(nameStr[i].type != -1)
            {
                if(strcmp(nameStr[i].name, cmdName) == 0)
                {
                    isFound = 1;
                    break;
                }
                i++;
            }

            DPRINT_INFO(WFA_OUT, "%s\n", cmdName);

            if(isFound == 0)
            {
                sleep(1);
                sprintf(respStr, "status,INVALID\r\n");
                wfaCtrlSend(gCaSockfd, (BYTE *)respStr, strlen(respStr));
                DPRINT_WARNING(WFA_WNG, "Command not valid, check the name\n");
                continue;
            }

            memset(pcmdBuf, 0, WFA_BUFF_1K); 
            if(nameStr[i].cmdProcFunc(pcmdStr, pcmdBuf, &cmdLen)==WFA_FAILURE)
            {
                sleep(1);
                sprintf(respStr, "status,INVALID\r\n");
                wfaCtrlSend(gCaSockfd, (BYTE *)respStr, strlen(respStr));
                DPRINT_WARNING(WFA_WNG, "Incorrect command syntax\n");
                continue;
            }

            /*
             * send to DUT.
             */
            if(send(gSock, pcmdBuf, cmdLen, 0) != cmdLen)
            {
                DPRINT_WARNING(WFA_WNG, "Incorrect sending ...\n");
                continue;
            }

            DPRINT_INFO(WFA_OUT, "sent to DUT\n");
            //sleep(1);
        } /* done with gCaSockfd */

        if(gSock > 0 && FD_ISSET(gSock, &sockSet))
        {
            DPRINT_INFO(WFA_OUT, "received from DUT\n");
            sleep(1);
            memset(respStr, 0, WFA_BUFF_128);
            memset(caCmdBuf, 0, WFA_BUFF_4K);
            if ((bytesRcvd = recv(gSock, caCmdBuf, WFA_BUFF_4K, 0)) <= 0)
            {
                DPRINT_WARNING(WFA_WNG, "recv() failed or connection closed prematurely");
                continue;
            }

#if DEBUG 
            for(i = 0; i< bytesRcvd; i++)
               printf("%x ", caCmdBuf[i]);
               printf("\n");
#endif
            tag = ((wfaTLV *)caCmdBuf)->tag;     
          
            memcpy(&ret_status, caCmdBuf+4, 4);

            DPRINT_INFO(WFA_OUT, "tag %i \n", tag);
            if(tag != 0 && wfaCmdRespProcFuncTbl[tag] != NULL)
            {
                wfaCmdRespProcFuncTbl[tag](caCmdBuf);
            }
            else
                DPRINT_WARNING(WFA_WNG, "function not defined\n");
        } /* if(gCaSock */

    } /* for */

    close(gSock);
    exit(0);
}
